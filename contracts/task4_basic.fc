#include "imports/stdlib.fc";

forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
(int) tlen (tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";
forall X -> tuple tuples::tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";
forall X -> (tuple, ()) ~tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

int toIndex(int a, int b) inline {
    int res = 0;
    if (b < 10) {
        res = a * 10 + b;
    } elseif ((b >= 10) & (b < 100)){
        res = a * 100 + b;
    }
    return res;
}


(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;; tuple moves = to_tuple([[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]);
    cell visited = new_dict();
    tuple stack = null();
    int i = 0;
    while (i < n){
        int j = 0;
        while (j < m) {
            slice s = maze.at(i).at(j);
            if (s~load_uint(8) == 83) {
                stack~push_back(triple(i, j, empty_tuple()));
                i = 33;
                j = 33;
            }
            j += 1;
        }
        i += 1;
    }

    while (~ stack.is_null()){
        (int i, int j, tuple path) = untriple(stack~pop_back());
        slice s = maze.at(i).at(j);

        if (s~load_uint(8) == 69) {
            int k = 1;
            while (k < path.tlen()) {
                maze.at(path.at(k).at(0)).tuples::tset(path.at(k).at(1), begin_cell().store_uint(33, 8).end_cell().begin_parse());
            }
            return (-1, 0, 0, maze);
        }

        int index = toIndex(i, j);
        (slice val, int flag) = visited.udict_get?(256, index);
        if (~ flag) {
            visited.udict_set(256, index, begin_cell().end_cell().begin_parse());

            (int new_i, int new_j) = (i + 1, j + 0);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i - 1, j + 0);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i + 0, j + 1);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i + 0, j - 1);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i + 1, j + 1);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i + 1, j - 1);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i - 1, j + 1);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }

            (int new_i, int new_j) = (i - 1, j - 1);
            if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                slice s = maze.at(new_i).at(new_j);
                if (s~load_uint(8) != 88) {
                    path~tpush(pair(i, j));
                    stack~push_back(triple(new_i, new_j, path));
                }
            }
        }
    }

    return (-1, 0, 0, null());
}