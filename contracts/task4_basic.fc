#include "imports/stdlib.fc";

forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
(int) tlen (tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";
forall X -> tuple tuples::tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";
forall X -> (tuple, ()) ~tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}


(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    tuple moves = to_tuple([[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]);
    tuple visited = maze;
    tuple stack = null();
    int i = 0;
    while (i < n){
        int j = 0;
        while (j < m) {
            slice s = maze.at(i).at(j);
            if (s~load_uint(8) == 83) {
                stack~push_back(triple(i, j, empty_tuple()));
                i = 33;
                j = 33;
            }
            j += 1;
        }
        i += 1;
    }

    while (~ stack.is_null()){
        (int i, int j, tuple path) = untriple(stack~pop_back());
        slice s = maze.at(i).at(j);

        if (s~load_uint(8) == 69) {
            int k = 1;
            while (k < path.tlen()) {
                maze = maze.tuples::tset(path.at(k).at(0), maze.at(path.at(k).at(0)).tuples::tset(path.at(k).at(1), begin_cell().store_uint(33, 8).end_cell().begin_parse()));
            }
            return (-1, 0, 0, maze);
        }

        slice visit = visited.at(i).at(j);
        if (visit~load_uint(8) != 33) {
            visited = visited.tuples::tset(i, visited.at(i).tuples::tset(j, begin_cell().store_uint(33, 8).end_cell().begin_parse()));
            ;; visited.udict_set(256, index, begin_cell().end_cell().begin_parse());


            int mv = 0;
            while (mv < 8) {
                (int new_i, int new_j) = (i + moves.at(mv).at(0), j + moves.at(mv).at(1));
                if ((0 <= new_i) & (new_i < n) & (0 <= new_j) & (new_j < m)){
                    slice s = maze.at(new_i).at(new_j);
                    if (s~load_uint(8) != 88) {
                        path~tpush(pair(i, j));
                        stack~push_back(triple(new_i, new_j, path));
                    }
                }

                mv += 1;
            }

            
        }
    }

    return (-1, 0, 0, null());
}